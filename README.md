# CS255

•	Briefly summarize the DriverPass project. Who was the client? What type of system did they want you to design?

The project is for DriverPass, a company that offers driving lessons, classes, and practice tests. The project’s purpose is to provide better driving training to customers who are preparing for their driving tests. It should include online classes and practice tests, and it should enable customers to purchase lesson packages and schedule their on-the-road lessons. The system should also be flexible, allowing the owner to access data from anywhere, and it must be secure, implementing both software security measures and compliance with DMV standards.


•	What did you do particularly well?

I did well with my UML diagrams. I broke up the use case diagrams into 4 intuitive categories, and broadly speaking, used the diagrams to make thorough and clear documentation. 


•	If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?

I would be more thorough in listing technical requirements in the System Design Document. 


•	How did you interpret the user’s needs and implement them into your system design? Why is it so important to consider the user’s needs when designing?

I implemented the user’s needs through an iterative process of considering the system implementation that would meet them, refining my description of the implementation from a functional perspective, returning to the question of how now-refined implementation matches up with the user’s needs, and repeating. The user’s needs are paramount since the user will be working with the system. A system that fails to meet those needs will not be used or will only be used as much as the user has to according to their work environment; its benefit will be significantly curtailed.


•	How do you approach designing software? What techniques or strategies would you use in the future to analyze and design a system?

Designing software should start with a clear idea of what the software must accomplish and given that set of functions the designer must identify outcomes that must not occur. The process then works towards figuring out what low-level software components will integrate into the full program or system and beginning to work on those. Going forward, I think emphasis on modularity will be an important part of my approach, since it makes software a great deal more maintainable, and in a highly modular project it is possible to being coding work very early, since even if software units made before the design is fully fleshed out turn out to be totally useless, they are far more easily replaced because the extent of their integration is limited and clearly defined.  
